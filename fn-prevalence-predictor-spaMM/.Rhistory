covs_sf_df$prev)
# Try v-folds HAL fitting with GAM metalearner
origami::make_folds(test)
# Try v-folds HAL fitting with GAM metalearner
folds_list <- origami::make_folds(test)
folds_list[[1]]
folds_list[[1]]$v
folds_list[[2]]$v
folds_list[[1]]$training_set
folds_list_to_df_list <- function(df, fold) {
df[fold$training_set]
}
folds_list_to_df_list <- function(fold, df) {
df[fold$training_set]
}
lapply(folds_list, folds_list_to_df_list, df = test)
folds_list_to_df_list <- function(fold, df) {
df[fold$training_set,]
}
lapply(folds_list, folds_list_to_df_list, df = test)
tt<-lapply(folds_list, folds_list_to_df_list, df = test)
length(tt)
tt[[1]]
dim(tt[[1]])
dim(tt[[2]])
dim(tt[[3]])
dim(test)
# Try v-folds HAL fitting with GAM metalearner
folds_list <- origami::make_folds(test, k=10)
?make_folds
# Try v-folds HAL fitting with GAM metalearner
folds_list <- origami::make_folds(test)
folds_list_to_df_list <- function(fold, df) {
df[fold$training_set,]
}
tt<-lapply(folds_list, folds_list_to_df_list, df = test)
# Try v-folds HAL fitting with GAM metalearner
folds_list <- origami::make_folds(test)
folds_list_to_df_list <- function(fold, df) {
train = df[fold$training_set,]
valid = df[fold$validation_set,]
list(train, valid)
}
tt<-lapply(folds_list, folds_list_to_df_list, df = test)
tt[[1]]
list(train = train,
valid = valid)
folds_list_to_df_list <- function(fold, df) {
train = df[fold$training_set,]
valid = df[fold$validation_set,]
list(train = train,
valid = valid)
}
tt<-lapply(folds_list, folds_list_to_df_list, df = test)
tt[[1]]$train
tt[[1]]$valid
folds_df_list <- lapply(folds_list, folds_list_to_df_list, df = test)
?mclapply
?make_folds
X_var <- c("elev", "tmin", "prec", "lat", "lng")
n_pos_var <- "Npos"
n_neg_var <- "Nneg"
folds_df_list_fold <- folds_df_list[[1]]
folds_df_list[[1]]
X_var
X <- folds_df_list_fold$train[,X_var]
X
X-var <- c("elev", "tmin", "prec")
X_var <- c("elev", "tmin", "prec")
X <- folds_df_list_fold$train[,X_var]
Y <- cbind(folds_df_list_fold$train[,n_neg_var],
folds_df_list_fold$train[,n_pos_var])
Y
hal_mod <- fit_hal(X, Y, family = "binomial")
pred_data <- folds_df_list_fold$valid[,X_var]
fitted_predictions <- predict(hal_fit, new_data = pred_data)
fitted_predictions
Y
X <- folds_df_list_fold$train[,X_var]
Y <- cbind(folds_df_list_fold$train[,n_neg_var],
folds_df_list_fold$train[,n_pos_var])
pred_data <- folds_df_list_fold$valid[,X_var]
hal_mod <- fit_hal(X, Y, family = "binomial")
fitted_predictions <- predict(hal_fit, new_data = pred_data)
fitted_predictions
plot(fitted_predictions, folds_df_list_fold$valid$prev)
plot(hal_mod)
hal_mod$coefs
plot(hal_mod$x_basis)
hal_mod$x_basis
folds_df_list_fold$train[,X_var]
folds_df_list_fold$valid[,X_var]
apply(folds_df_list_fold$valid[,X_var],2, mean)
apply(folds_df_list_fold$train[,X_var],2, mean)
Y <- cbind(folds_df_list_fold$train[,n_pos_var],
folds_df_list_fold$train[,n_neg_var])
pred_data <- folds_df_list_fold$valid[,X_var]
hal_mod <- fit_hal(X, Y, family = "binomial")
fitted_predictions <- predict(hal_fit, new_data = pred_data)
fitted_predictions
folds_df_list_fold$train[,n_pos_var]
fitted_predictions <- predict(hal_mod, new_data = pred_data)
fitted_predictions
plot(fitted_predictions, folds_df_list_fold$valid$prev)
X <- folds_df_list_fold$train[,X_var]
Y <- cbind(folds_df_list_fold$train[,n_neg_var],
folds_df_list_fold$train[,n_pos_var])
pred_data <- folds_df_list_fold$valid[,X_var]
hal_mod <- fit_hal(X, Y, family = "binomial")
fitted_predictions <- predict(hal_mod, new_data = pred_data)
plot(fitted_predictions, folds_df_list_fold$valid$prev)
fit_hal_parallel <- function(folds_df_list_fold,
X_var,
n_pos_var,
n_neg_var){
X <- folds_df_list_fold$train[,X_var]
Y <- cbind(folds_df_list_fold$train[,n_neg_var],
folds_df_list_fold$train[,n_pos_var])
pred_data <- folds_df_list_fold$valid[,X_var]
hal_mod <- fit_hal(X, Y, family = "binomial")
predict(hal_mod, new_data = pred_data)
}
?mclapply
X_var
n_pos_var
# Apply function in parallel
mclapply(folds_df_list, FUN = fit_hal_parallel,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_pneg_var = "Nneg")
library(parallel)
# Apply function in parallel
mclapply(folds_df_list, FUN = fit_hal_parallel,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_pneg_var = "Nneg")
# Apply function in parallel
mclapply(folds_df_list, FUN = fit_hal_parallel,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_neg_var = "Nneg")
getOption("mc.cores", 2L)
getOption("mc.cores")
getOption("mc.cores", 3L)
# Apply function in parallel
mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = 4,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_neg_var = "Nneg")
# Apply function in parallel
mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = 6,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_neg_var = "Nneg")
# Apply function in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = 6,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_neg_var = "Nneg")
folds_list
length(folds_list)
unlist(folds_list)
# Add cv predictions back onto data.frame
valid_indeces <- sapply(folds_list, function(x){x$validation_set})
valid_indeces
# Add cv predictions back onto data.frame
valid_indeces <- unlist(sapply(folds_list, function(x){x$validation_set}))
valid_indeces
cv_predictions
unlist(cv_predictions)
test$cv_preds[valid_indeces] <- unlist(cv_predictions)
plot(test$prev, test$cv_preds)
# Now fit GAM model with GP spatial effect as meta-learner
meta_gam <- gam(cbind(Npos, Nneg) ~
s(cv_preds, k=-1) +
s(lng, lat, k=-1, bs="gp"),
family = binomial,
data = test
)
plot(meta_gam)
# Now fit GAM model with GP spatial effect as meta-learner
meta_gam <- gam(cbind(Npos, Nneg) ~
#s(cv_preds, k=-1) +
s(lng, lat, cv_preds, k=-1, bs="gp"),
family = binomial,
data = test
)
plot(meta_gam)
plot(predict(meta_gam, test), type="response",
test$prev)
plot(predict(meta_gam, test, type="response"),
test$prev)
# Now fit GAM model with GP spatial effect as meta-learner
meta_gam <- gam(cbind(Npos, Nneg) ~
s(cv_preds, k=-1) +
s(lng, lat, k=-1, bs="gp"),
family = binomial,
data = test
)
plot(predict(meta_gam, test, type="response"),
test$prev)
plot(predictions, test$prev)
X <- test[,c("elev", "tmin", "prec", "lat", "lng")]
Y <- cbind(test$Nneg, test$Npos)
hal_fit <- fit_hal(X, Y, family = "binomial")
predictions <- predict(hal_fit, new_data = X)
plot(predictions, test$prev)
plot(predict(meta_gam, test, type="response"),
test$prev)
plot(meta_gam)
plot(test$prev, test$cv_preds)
plot(predict(meta_gam, test, type="response"))
plot(test$prev, test$cv_preds)
plot(predict(meta_gam, test, type="response"),
test$prev)
abline(0,1)
predictions
# If you want to look at fitted values
test_df_for_fitted <- test
test_df_for_fitted$cv_preds <- predictions
plot(predict(meta_gam, test_df_for_fitted, type="response"),
test$prev)
plot(predictions, test$prev)
# Fit a HAL model
X <- test[,c("elev", "tmin", "prec")]
Y <- cbind(test$Nneg, test$Npos)
hal_fit <- fit_hal(X, Y, family = "binomial")
predictions <- predict(hal_fit, new_data = X)
plot(predictions, test$prev)
plot(predict(meta_gam, test_df_for_fitted, type="response"),
test$prev)
plot(predictions, test$prev)
points((predict(meta_gam, test_df_for_fitted, type="response"),
test$prev), pch=16)
points(predict(meta_gam, test_df_for_fitted, type="response"),
test$prev, pch=16)
abline(0,1,col="red")
params <- readLines(fromJSON("~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn/test_req.json"))
params <- readLines("~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn/test_req.json")
params
fromJSON(params)
params[['number']]
params <- fromJSON(params)
params[['number']]
# run function and catch result
result = params[['number']] + 1
result
if (result == 1) stop('FAKE ERROR: Do not give me zero')
# wrap up result to match output structure from docs
response = list(unbox(result))
?unbox
getwd()
setwd("~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn")
source('~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn/main.R')
source('~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn/main.R')
source('~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn/main.R')
result = params[['number']] + 1
result
params[['number']]
params
fromJSON(readLines("test_req.json"))
is.null(params[['number']])
!is.numeric(params[['number']]
)
source('~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn/main.R')
params
is.null(params[["number"]])
!is.numeric(params[["number"]])
length(params[["number"]]) != 1
if (is.null(params[["number"]])) {
stop("Missing `number` parameter")
}
if (!is.numeric(params[["number"]])) {
stop("Parameter `number` is not numeric")
}
if (length(params[["number"]]) != 1) {
stop("Only pass a single value for `number")
}
params
source('~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn/main.R')
retrieve_remote_files(params)
params
retrieve_remote_files
# reads STDIN as JSON, return error if any problems
#params = fromJSON(readLines(file("stdin")))
params = fromJSON(readLines("test_req.json"))
params
retrieve_remote_files(params)
params
# checks for existence of required parameters, return error if any problems
# checks types/structure of all parameters, return error if any problems
# as required, replace any external URLs with data
params = preprocess_params(params)
params
source('~/Documents/Work/MEI/DiSARM/GitRepos/faas-template-r-function/faas-template-r-fn/main.R')
# reads STDIN as JSON, return error if any problems
#params = fromJSON(readLines(file("stdin")))
params = fromJSON(readLines("test_req.json"))
# checks for existence of required parameters, return error if any problems
# checks types/structure of all parameters, return error if any problems
# as required, replace any external URLs with data
preprocess_params(params)
params
retrieve_remote_files(params)
# run the function with parameters,
# return error if any problems, return success if succeeds
function_response = run_function(params)
result = params[['number']] + 1
result
detectCores()
params <- fromJSON(readLines("~/Downloads/test_input.json"))
points <- params$point_data
points
points_df <- as.data.frame(points)
points_df$n_negative <- points_df$n_trials - points_df$n_positive
names(points_df)
points <- st_read(points)
points <- st_read(as.json
(points))
points
points_df <- as.data.frame(points)
points_df$n_negative <- points_df$n_trials - points_df$n_positive
points_df$n_negative
1-NA
NA-1
# Filter out training data
points_df_copy <- points_df
points_df_copy$row_id <- 1:nrow(points_df_copy)
points_df_copy_train <- points_df_copy[which(!(is.na(points_df_copy$n_negative))),]
points_df_copy_train
dim(points_df_copy_train)
dim(points_df_copy)
# Create folds
folds_list <- origami::make_folds(points_df_copy_train)
folds_list_to_df_list <- function(fold, df) {
train = df[fold$training_set,]
valid = df[fold$validation_set,]
list(train = train,
valid = valid)
}
fit_hal_parallel <- function(folds_df_list_fold,
X_var,
n_pos_var,
n_neg_var){
X <- folds_df_list_fold$train[,X_var]
Y <- cbind(folds_df_list_fold$train[,n_neg_var],
folds_df_list_fold$train[,n_pos_var])
pred_data <- folds_df_list_fold$valid[,X_var]
hal_mod <- fit_hal(X, Y, family = "binomial")
predict(hal_mod, new_data = pred_data)
}
getwd()
folds_df_list <- lapply(folds_list, folds_list_to_df_list, df = points_df)
folds_df_list
# Now apply HAL to each fold in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = detectCores() - 1,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_neg_var = "Nneg")
fit_hal_parallel
# Now apply HAL to each fold in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = 5,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_neg_var = "Nneg")
length(folds_df_list)
names(points_df_copy_train)
params <- fromJSON(readLines("~/Downloads/test_req_cv_hal.json"))
params <- fromJSON(readLines("~/Downloads/test_req_cv_hal.json"))
params <- fromJSON(readLines("~/Downloads/test_req_cv_hal.json"))
params <- fromJSON(readLines("~/Downloads/test_req_cv_hal.json"))
params <- fromJSON(readLines("~/Downloads/test_req_cv_hal.json"))
params$points
# Load points into memory
params$points <- st_read(as.json(params[['points']]), quietly = TRUE)
# Check the layer names are present in points
layer_names <- params[['layer_names']]
params[['points']]
as.json(params[['points']])
st_read(as.json(params[['points']]))
# Load points into memory
params$points <- st_read(as.json(params[['points']]), quiet = TRUE)
# Check the layer names are present in points
layer_names <- params[['layer_names']]
if(!(sum(layer_names %in% names(points)) == length(layer_names))){
stop('Not all layer_names present in points')
}
layer_names
names(points)
params
# Load points into memory
params$points <- st_read(as.json(params[['points']]), quiet = TRUE)
as.json(params[['points']])
params[['points']]
names(params$points)
if(!(sum(layer_names %in% names(params$points)) == length(layer_names))){
stop('Not all layer_names present in points')
}
# run function and catch result
points <- params[['points']]
points
points_df <- as.data.frame(points)
points_df$n_negative <- points_df$n_trials - points_df$n_positive
# Filter out training data
points_df_copy <- points_df
points_df_copy$row_id <- 1:nrow(points_df_copy)
points_df_copy_train <- points_df_copy[which(!(is.na(points_df_copy$n_negative))),]
points_df_copy_train
# Create folds
folds_list <- origami::make_folds(points_df_copy_train)
folds_df_list <- lapply(folds_list, folds_list_to_df_list, df = points_df)
# Now apply HAL to each fold in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = detectCores() - 1,
X_var = c("elev", "tmin", "prec"),
n_pos_var = "Npos",
n_neg_var = "Nneg")
# Now apply HAL to each fold in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = detectCores() - 1,
X_var = c("elev_m", "dist_to_water_m", "bioclim1", "bioclim4"),
n_pos_var = "Npos",
n_neg_var = "Nneg")
# Now apply HAL to each fold in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = detectCores() - 1,
X_var = c("elev_m", "dist_to_water_m", "bioclim1", "bioclim4"),
n_pos_var = "n_positive",
n_neg_var = "n_negative")
folds_df_list[[1]]
folds_df_list <- lapply(folds_list, folds_list_to_df_list, df = points_df_copy_train)
# Now apply HAL to each fold in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = detectCores() - 1,
X_var = c("elev_m", "dist_to_water_m", "bioclim1", "bioclim4"),
n_pos_var = "n_positive",
n_neg_var = "n_negative")
cv_predictions
# Add cv predictions back onto data.frame
valid_indeces <- unlist(sapply(folds_list, function(x){x$validation_set}))
valid_indeces
points_df_copy_train$cv_preds[valid_indeces] <- unlist(cv_predictions)
points_df_copy_train$cv_preds
plot(points_df_copy_train$cv_preds, points_df_copy_train$n_positive/points_df_copy_train$n_trials)
# Filter out training data
points_df$row_id <- 1:nrow(points_df)
points_df_train <- points_df[which(!(is.na(points_df$n_negative))),]
# Create folds
folds_list <- origami::make_folds(points_df_train)
folds_df_list <- lapply(folds_list, folds_list_to_df_list, df = points_df_train)
# Now apply HAL to each fold in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = detectCores() - 1,
X_var = c("elev_m", "dist_to_water_m", "bioclim1", "bioclim4"),
n_pos_var = "n_positive",
n_neg_var = "n_negative")
# Add cv predictions back onto data.frame
valid_indeces <- unlist(sapply(folds_list, function(x){x$validation_set}))
points_df_train$cv_preds[valid_indeces] <- unlist(cv_predictions)
points_df_train$cv_preds
layer_names <- params[['layer_names']]
# Now apply HAL to each fold in parallel
cv_predictions <- mclapply(folds_df_list, FUN = fit_hal_parallel,
mc.cores = detectCores() - 1,
X_var = layer_names,
n_pos_var = "n_positive",
n_neg_var = "n_negative")
layer_names
points_df_train$row_id
with_data <- which(!(is.na(points_df$n_negative)))
points_df_pred <- points_df[-with_data,]
# Now fit HAL to full dataset and create fitted predictions
hal_fit <- fit_hal(X = points_df[,layer_names],
Y = cbind(points_df$n_negative,
points_df$n_positive),
family = "binomial")
# Now fit HAL to full dataset and create fitted predictions
hal_fit <- fit_hal(X = points_df_train[,layer_names],
Y = cbind(points_df_train$n_negative,
points_df_train$n_positive),
family = "binomial")
points_df$fitted_predictions <- predict(hal_fit, new_data = points_df)
predict(hal_fit, new_data = points_df)
names(points_df)
mode(points_df)
is.data.frame(points_df)
points_df$fitted_predictions <- predict(hal_fit, new_data = points_df[,layer_names])
points_df$fitted_predictions
points_df_train$row_id[valid_indeces]
valid_indeces[1]
points_df[1:25,]
points_df$cv_predictions[points_df_train$row_id[valid_indeces]] <- unlist(cv_predictions)
source('~/Documents/Work/MEI/DiSARM/GitRepos/fn-cv-HAL/fn-cv-HAL/function/function.R', echo=TRUE)
points_df$cv_predictions <- NA
points_df$cv_predictions <- NA
points_df$cv_predictions[points_df_train$row_id[valid_indeces]] <- unlist(cv_predictions)
points_df$cv_predictions
plot(points_df$cv_predictions, points_df$n_positive/points_df$n_trials)
head(points_df)
points$fitted_predictions <- predict(hal_fit, new_data = points_df[,layer_names])
points$cv_predictions <- NA
points$cv_predictions[points_df_train$row_id[valid_indeces]] <- unlist(cv_predictions)
plot(points$cv_predictions, points$n_positive/points_df$n_trials)
plot(points$cv_predictions, points$n_positive/points$n_trials)
library(parallel)
install.packages('parallel')
install.packages("parallel")
