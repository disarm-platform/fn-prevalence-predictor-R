sizes = rep(100, nrow(new_data))
#
get_bci_width <- function(realization){
quantiles <- quantile(realization, prob = c(0.025, 0.975))
}
prevalence_bci_width <- apply(sims)
- `id` - as defined by user or 1:n (where n is the number of Features in the FeatureCollection)
- `prevalence_prediction` - best-guess (probability of occurrence (0-1 scale))
- `prevalence_bci_width` - difference between upper 97.5% and lower 2.25% quantiles
- `exceedance_probability` - Only exists if `exceedance_threshold` provided
- `exceedance_uncertainty` - Only exists if `exceedance_threshold` provided
}
sims <- simulate(spaMM_mod,
type = "(ranef|response)",
nsim = n_sims,
newdata = new_data,
sizes = rep(100, nrow(new_data)))
hist(sims[10,])
predict(spaMM_mod)[10]
mean(sims[1,])
mean(sims[10,])
median(sims[1,])
median(sims[10,])
quantiles
diff(quantiles)
realization <- sims[10,]
quantiles <- quantile(realization, prob = c(0.025, 0.975))
diff(quantiles)
quantiles
as.vector(diff(quantiles))
get_bci_width <- function(realization){
quantiles <- quantile(realization, prob = c(0.025, 0.975))
return(as.vector(diff(quantiles)))
}
prevalence_bci_width <- apply(sims, 1, get_bci_width)
prevalence_bci_width
head(prevalence_bci_width)
sims[1,]
range(sims[1,])
sims <- sims/100
get_bci_width <- function(realization){
quantiles <- quantile(realization, prob = c(0.025, 0.975))
return(as.vector(diff(quantiles)))
}
predict(spaMM_mod, new_data)
params$exceedance_threshold
!is.null(params$exceedance_threshold)
apply(sims, 1, function(x){sum(x >= exceedance_threshold)/
n_sims})
exceedance_threshold <- params$exceedance_threshold
exceedance_probability <- apply(sims, 1, function(x){sum(x >= exceedance_threshold)/
n_sims})
exceedance_probability
0.5 - abs(exceedance_probability - 0.5)
# Calc 'exceedance_uncertainty' as normalized around 0.5
exceedance_uncertainty <- 0.5 - abs(exceedance_probability - 0.5)
plot(exceedance_probability, exceedance_uncertainty)
getwd()
get_posterior_metrics <- dget("function/helpers.R")
params$exceedance_threshold
get_posterior_metrics(spaMM_mod,
mod_data,
200,
params$exceedance_threshold)
posterior_metrics <- get_posterior_metrics(spaMM_mod,
mod_data,
200,
params$exceedance_threshold)
spaMM_mod
point_data
cbind(point_data, posterior_metrics)
ttcbind(point_data, posterior_metrics)
tt<-cbind(point_data, posterior_metrics)
tt
View(tt)
tt[[1]]
tt[[2]]
point_data
names(posterior_metrics)
get_posterior_metrics <- dget("function/helpers.R")
posterior_metrics <- get_posterior_metrics(spaMM_mod,
mod_data,
200,
params$exceedance_threshold)
names(posterior_metrics)
i <- names(posterior_metrics)[1]
posterior_metrics[[i]]
point_data[[i]] <- posterior_metrics[[i]]
point_data
for(i in names(posterior_metrics)){
point_data[[i]] <- posterior_metrics[[i]]
}
point_data
plot(point_data$n_trials/point_data$n_positive, point_data$prevalence_prediction)
plot(point_data$n_positive/point_data$n_trials, point_data$prevalence_prediction)
abline(0,1)
plot(predict(spaMM), mod_data$n_positive/ mod_data$n_trials)
plot(predict(spaMM_mod), mod_data$n_positive/ mod_data$n_trials)
dim(train_data)
plot(predict(spaMM_mod), train_dataa$n_positive/ train_data$n_trials)
plot(predict(spaMM_mod), train_data$n_positive/ train_data$n_trials)
head(new_data)
dim(new_data)
dim(train_data)
predict(new_data)
predict(spaMM_mod,new_data)
new_data$n_positive/new_data$n_trials
head(new_data)
head(train_data)
exceedance_probability
entropy <- -exceedance_probability * log(exceedance_probability) -
(1-exceedance_probability) * log (1-exceedance_probability)
entropy
plot(entropy, exceedance_probability)
exceedance_probability[441]
entropy[is.na(entropy)]
spaMM_mod$eta
spaMM_mod$CorrEst_and_RanFix
spaMM_mod$CorrEst_and_RanFix$corrPars
shiny::runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
# parse result
json_response <-
httr::content(response, as = 'text') # this extracts the response from the request object
json_response
result <-
rjson::fromJSON(json_response) # this will put the response in a useful format
content(response)
?simulate
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
# parse result
json_response <-
httr::content(response, as = 'text') # this extracts the response from the request object
result <-
rjson::fromJSON(json_response) # this will put the response in a useful format
result_sf <- st_read(as.json(result$result))
result$result
head(as.json(result$result))
response <-  httr::POST(url = "https://faas.srv.disarm.io/function/fn-prevalence-predictor-spamm",
body = RJSONIO::toJSON(input_data_list, .na="null"),
content_type_json())
print(response$status_code)
# parse result
json_response <-
httr::content(response, as = 'text') # this extracts the response from the request object
result <-
rjson::fromJSON(json_response) # this will put the response in a useful format
result_sf <- st_read(as.json(result$result))
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
points <- read.csv("~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points/data/Sm_cdi.csv")
# Change IDs to characters in case they come in as levels
points$id <- as.character(points$id)
# Convert to sf object
points_sf <- st_as_sf(SpatialPointsDataFrame(SpatialPoints(points[,c("lng", "lat")]),
points[,c("n_trials", "n_positive", "id")]))
point_data <- point_sf
# Send to covariate_extractor
cov_ext_input_data_list <- list(points = geojson_list(point_data),
layer_names = params$layer_names)
layer_names
params$layer_names
response <-
httr::POST(
url = "https://faas.srv.disarm.io/function/fn-covariate-extractor",
body = as.json(cov_ext_input_data_list),
content_type_json(),
timeout(90)
)
# Get contents of the response
response_content <- content(response)
points_sf <- st_read(as.json(response_content$result), quiet = TRUE)
# Annoyingly values come back as factors, so change back to numeric
points_sf$n_trials <- as.numeric(as.character(points_sf$n_trials))
points_sf$n_positive <- as.numeric(as.character(points_sf$n_positive))
points_sf$n_trials
dim(points)
points_sf
SpatialPoints(points[,c("lng", "lat")])
# Convert to sf object
points_sf <- st_as_sf(SpatialPointsDataFrame(SpatialPoints(points[,c("lng", "lat")]),
points[,c("n_trials", "n_positive", "id")]))
points_sf
point_data <- point_sf
point_data <- points_sf
# Send to covariate_extractor
cov_ext_input_data_list <- list(points = geojson_list(point_data),
layer_names = params$layer_names)
response <-
httr::POST(
url = "https://faas.srv.disarm.io/function/fn-covariate-extractor",
body = as.json(cov_ext_input_data_list),
content_type_json(),
timeout(90)
)
# Get contents of the response
response_content <- content(response)
points_sf <- st_read(as.json(response_content$result), quiet = TRUE)
# Annoyingly values come back as factors, so change back to numeric
points_sf$n_trials <- as.numeric(as.character(points_sf$n_trials))
points_sf$n_positive <- as.numeric(as.character(points_sf$n_positive))
# Now pass into fn-cv-ml
cv_hal_input_data_list <- list(points = geojson_list(points_sf),
layer_names = params$layer_names)
response_cv_ml <-
httr::POST(
url = "https://faas.srv.disarm.io/function/fn-cv-ml",
body = as.json(cv_hal_input_data_list),
content_type_json(),
timeout(90)
)
response_content_cv_ml <- content(response_cv_ml)
# Clean up data ready to pass into model
mod_data_sf <- st_read(as.json(response_content_cv_ml$result$points), quiet=TRUE)
mod_data_sf
mod_data <- as.data.frame(mod_data_sf)
mod_data <- cbind(mod_data, st_coordinates(mod_data_sf))
mod_data$cv_predictions <- as.numeric(as.character(mod_data$cv_predictions))
mod_data$fitted_predictions <- as.numeric(as.character(mod_data$fitted_predictions))
mod_data$n_trials <- as.numeric(as.character(mod_data$n_trials))
mod_data$n_positive <- as.numeric(as.character(mod_data$n_positive))
mod_data$n_neg <- mod_data$n_trials - mod_data$n_positive
train_data <- mod_data[!is.na(mod_data$n_trials),]
pred_data <- mod_data[is.na(mod_data$n_trials),]
dim(train_data)
head(train_data)
# Fit model
spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
Matern(1|X+Y),
data=train_data,
family=binomial())
?fitme
system.time(mean(1:100))
# Fit model
system.time(spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
Matern(1|X+Y),
init=list(phi=1),
data=train_data,
family=binomial()))
spaMM_mod$corrPars
1/169
# Fit model
system.time(spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
Matern(1|X+Y),
init = list(nu = 0.06, rho = 170),
data=train_data,
family=binomial()))
spaMM_mod
LoaLoa
data("Loaloa")
View(Loaloa)
loa_fit <- fitme(cbind(npos,ntot-npos)~
elev1+elev2+elev3+elev4+maxNDVI1+seNDVI+Matern(1|longitude+latitude),
family=binomial(), data=Loaloa)
train_data_samp <- train_data[sample(1:nrow(train_data), 200),]
dim(train_data_samp )
system.time(spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
Matern(1|X+Y),
data=train_data_samp,
family=binomial()))
spaMM_mod
dim(train_data)
spLoaloa <- sp::SpatialPointsDataFrame(
coords = train_data[, c("X", "Y")],
data = Loaloa)
spLoaloa <- sp::SpatialPointsDataFrame(
coords = train_data[, c("X", "Y")],
data = train_data)
library(INLA)
sp_train_data <- sp::SpatialPointsDataFrame(
coords = train_data[, c("X", "Y")],
data = train_data)
spde_mesh <- INLA::inla.mesh.2d(
loc = INLA::inla.mesh.map(sp::coordinates(sp_train_data)),
max.edge = c(3, 20))
plot(spde_mesh)
spde_mesh <- INLA::inla.mesh.2d(
loc = INLA::inla.mesh.map(sp::coordinates(sp_train_data)),
max.edge = c(2, 20))
plot(spde_mesh)
spde_mesh <- INLA::inla.mesh.2d(
loc = INLA::inla.mesh.map(sp::coordinates(sp_train_data)),
max.edge = c(0.5, 5))
plot(spde_mesh)
dim(spde_mesh)
spde_mesh
spde_mesh <- INLA::inla.mesh.2d(
loc = INLA::inla.mesh.map(sp::coordinates(sp_train_data)),
max.edge = c(1, 5))
spde_mesh
plot(spde_mesh)
train_data_spde <- INLA::inla.spde2.matern(spde_mesh)
system.time(spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
IMRF(1|X+Y, model = train_data_spde),
data=train_data,
family=binomial()))
spde_mesh <- INLA::inla.mesh.2d(
loc = INLA::inla.mesh.map(sp::coordinates(sp_train_data)),
max.edge = c(0.5, 5))
train_data_spde <- INLA::inla.spde2.matern(spde_mesh)
system.time(spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
IMRF(1|X+Y, model = train_data_spde),
data=train_data,
family=binomial()))
plot(spde_mesh)
spde_mesh <- INLA::inla.mesh.2d(
loc = INLA::inla.mesh.map(sp::coordinates(sp_train_data)),
max.edge = c(0.5, 2))
plot(spde_mesh)
train_data_spde <- INLA::inla.spde2.matern(spde_mesh)
system.time(spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
IMRF(1|X+Y, model = train_data_spde),
data=train_data,
family=binomial()))
system.time(spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
(1|X+Y),
data=train_data,
family=binomial()))
head(train_data)
system.time(spaMM_mod <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
(1|id),
data=train_data,
family=binomial()))
spaMM_mod
system.time(spaMM_mod_non_sp <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
(1|id),
data=train_data,
family=binomial()))
system.time(spaMM_mod_samp <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
Matern(1|X+Y),
data=train_data_samp,
family=binomial()))
spaMM_mod_samp
spaMM_mod_non_sp
system.time(spaMM_mod_non_sp <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
(1|id),
data=train_data_samp,
family=binomial()))
spaMM_mod_non_sp$ranef
hist(spaMM_mod_non_sp$ranef)
plot(spaMM_mod_non_sp$ranef, spaMM_mod_samp$ranef)
?refit
?fitme
spaMM_mod$CorrEst_and_RanFix
spaMM_mod$corrPars
get_ranPars(spaMM_mod)
spaMM_mod$corrPars
spaMM_mod$CorrEst_and_RanFix$corrPars
spaMM_mod_samp$corrPars
get_ranPars(spaMM_mod_samp)
system.time(spaMM_mod_fixed <- fitme(cbind(n_positive, n_neg) ~
cv_predictions +
Matern(1|X+Y),
fixed = list(nu = 0.032823,
rho = 94.60928),
data=train_data,
family=binomial()))
spaMM_mod_fixed
spaMM_mod_samp
plot(predict(spaMM_mod_fixed), train_data$n_positive/train_data$n_trials)
abline(0,1)
dim(train_data)
spaMM_mod_samp
spaMM_mod_samp$CorrEst_and_RanFix$lambda
?fitme
spaMM_mod_samp$CorrEst_and_RanFix$lambda
spaMM_mod$CorrEst_and_RanFix$lambda
spaMM_mod
spaMM_mod$CorrEst_and_RanFix$corrPars
spaMM_mod_samp$CorrEst_and_RanFix$corrPars
spaMM_mod_samp$CorrEst_and_RanFix$corrPars$'1'$rho
posterior_metrics <- get_posterior_metrics(spaMM_mod,
mod_data,
200,
params$exceedance_threshold)
head(posterior_metrics)
plot(posterior_metrics$prevalence_prediction, mod_data$n_positive/mod_data$n_trials)
tt <- fromJSON(readLines("test_req.json"))
getwd()
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
runApp('~/Documents/Work/MEI/DiSARM/GitRepos/ntd-shiny-points')
rm(list=ls())
ETH_malaria_data <- read.csv("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week1/Lab_files/Data/mal_data_eth_2009_no_dups.csv",header=T)
oromia <- ETH_Adm_1[ETH_Adm_1$NAME_1=="Oromia",]
oromia_window <- owin(oromia@bbox[1,], oromia@bbox[2,])
#Then define a ppp of the prevalence data
ETH_malaria_data_ppp<-ppp(ETH_malaria_data$longitude,ETH_malaria_data$latitude,
marks=ETH_malaria_data$pf_pr,window=oromia_window)
ETH_Adm_1 <- raster::getData("GADM", country="ETH", level=1)
oromia <- ETH_Adm_1[ETH_Adm_1$NAME_1=="Oromia",]
oromia_window <- owin(oromia@bbox[1,], oromia@bbox[2,])
#Then define a ppp of the prevalence data
ETH_malaria_data_ppp<-ppp(ETH_malaria_data$longitude,ETH_malaria_data$latitude,
marks=ETH_malaria_data$pf_pr,window=oromia_window)
powers <- seq(0.05, 2, 0.05)
mse_result <- NULL
for(power in powers){
CV_idw <- idw(ETH_malaria_data_ppp, power=power, at="points")
mse_result <- c(mse_result,
mse(ETH_malaria_data_ppp$marks,CV_idw))
}
library(Metrics)
library(spatstat)
library(raster)
library(sp)
library(geoR)
library(gtools)
library(lme4)
library(leaflet)
library(oro.nifti)
for(power in powers){
CV_idw <- idw(ETH_malaria_data_ppp, power=power, at="points")
mse_result <- c(mse_result,
mse(ETH_malaria_data_ppp$marks,CV_idw))
}
plot(mse_result)
optimal_power <- powers[which.min(mse_result)]
optimal_power
# Plot observed versus expected with optimal power
CV_idw_opt <- idw(ETH_malaria_data_ppp, power=optimal_power, at="points")
plot(ETH_malaria_data_ppp$marks, CV_idw_1, asp=1)
plot(ETH_malaria_data_ppp$marks, CV_idw_opt, asp=1)
abline(o,1)
abline(0,1)
plot(mse_result)
# See which produced the lowest error
plot(powers, mse_result)
plot(powers, mse_result)
plot(ETH_malaria_data_ppp$marks, CV_idw_opt, asp=1)
plot(ETH_malaria_data_ppp$marks, CV_idw_opt)
optimal_power <- powers[which.min(mse_result)]
optimal_power
# Plot observed versus expected with optimal power
CV_idw_opt <- idw(ETH_malaria_data_ppp, power=optimal_power, at="points")
plot(ETH_malaria_data_ppp$marks, CV_idw_opt)
powers <- seq(0.05, 2, 0.05)
mse_result <- NULL
for(power in powers){
CV_idw <- idw(ETH_malaria_data_ppp, power=power, at="points")
mse_result <- c(mse_result,
mse(ETH_malaria_data_ppp$marks,CV_idw))
}
# See which produced the lowest error
optimal_power <- powers[which.min(mse_result)]
optimal_power
plot(powers, mse_result)
BF_land_use <- raster("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week2/Lab_files/BF_land_use.tif")
BF_land_use
crs(BF_land_use)
crs(BF_elev)
BF_elev <- raster::getData("alt", country="BF")
crs(BF_elev)
BF_land_use <- projectRaster(BF_land_use, crs=crs(BF_elev), method="ngb") # reproject
BF_elev_crop <- crop(BF_elev, extent(BF_elev,499,507, 301,309))
pop_crop <- crop(pop, extent(BF_elev_crop))
BF_land_use_crop <- crop(BF_land_use, extent(BF_elev_crop))
new_raster <- aggregate(BF_elev_crop, fact=3)
new_raster <- shift(new_raster, x=0.004, y=0.002)
new_raster_outline <- rasterToPolygons(new_raster, dissolve=TRUE)
pop <- raster("https://raw.githubusercontent.com/HughSt/HughSt.github.io/master/course_materials/week2/Assignment/BF_pop.tif")
pop_crop <- crop(pop, extent(BF_elev_crop))
new_raster <- aggregate(BF_elev_crop, fact=3)
new_raster <- raster::shift(new_raster, x=0.004, y=0.002)
new_raster_outline <- rasterToPolygons(new_raster, dissolve=TRUE)
?shift
new_raster
shift(new_raster, dx=0.004, dy=0.002)
new_raster <- raster::shift(new_raster, dx=0.004, dy=0.002)
new_raster_outline <- rasterToPolygons(new_raster, dissolve=TRUE)
plot(BF_elev_crop)
lines(new_raster_outline)
BF_elev_crop_resampled_bilin <- resample(BF_elev_crop, new_raster, method="bilinear")
plot(BF_elev_crop_resampled_bilin)
lines(new_raster_outline)
plot(BF_land_use_crop)
BF_land_use_crop
table(BF_land_use_crop[])
BF_land_use_crop_aggregated <- aggregate(BF_land_use_crop, fun='modal', fact = 9)
plot(BF_land_use_crop_aggregated)
lines(new_raster_outline)
BF_land_use_crop_aggregated_resamp <- resample(BF_land_use_crop_aggregated, new_raster, method = "ngb")
plot(BF_land_use_crop_aggregated_resamp)
lines(new_raster_outline)
plot(pop_crop, col=topo.colors(64))
cellStats(pop_crop, sum)
pop_crop_aggregated <- aggregate(pop_crop, fact = 3.012048, fun = sum)
cellStats(pop_crop_aggregated, sum)
plot(pop_crop_aggregated, col=topo.colors(64))
lines(new_raster_outline)
pop_crop_aggregated_resamp <- resample(pop_crop_aggregated, new_raster)
plot(pop_crop_aggregated_resamp, col=topo.colors(64))
lines(new_raster_outline)
cellStats(pop_crop_aggregated_resamp, sum)
?rasterToPolygons
?spaMM_boot
?colorNumeric
